/**
 * \class XLEFeaturesParser
 * \file XLEFeaturesParser.cpp
 *
 * \brief Provide a parser for XLE FEATURES section settings.
 *
 * The code for this parser is indirectly generated from the specification of the BNF
 * grammar for XLE FEATURES and the resulting parser class Skeleton.C generated by BNFC.
 *
 * \author Damir Cavar &lt;dcavar@iu.edu&gt;
 *
 * \version 0.1
 *
 * \date 2016/10/25 01:53:00
 *
 * \date Created on: Tue Oct 25 01:55:00 2016
 *
 * \copyright Copyright 2016 by Damir Cavar
 *
 * \license{Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.}
 *
 * \see XLEFeaturesParserTest
 *
 * \note This code should be considered alpha.
 *
 * \bug None
 */

#include "XLEFeaturesParser.h"

namespace xlefeatures {
    void XLEFeaturesParser::visitFEATURE(FEATURE *t) {} //abstract class
    void XLEFeaturesParser::visitRULE(RULE *t) {} //abstract class
    void XLEFeaturesParser::visitEXP(EXP *t) {} //abstract class
    void XLEFeaturesParser::visitEXDISJ(EXDISJ *t) {} //abstract class
    void XLEFeaturesParser::visitCATS(CATS *t) {} //abstract class
    void XLEFeaturesParser::visitSYMS(SYMS *t) {} //abstract class

    //XLEFeaturesParser::XLEFeaturesParser(){
    //    verbose = true;
    //}

    void XLEFeaturesParser::getConfig(const char *buffer) {
        FEATURE *parse_tree = pFEATURE(buffer);
        if (parse_tree) {
            parse_tree->accept(this);
        }
    }

    void XLEFeaturesParser::visitFeat(Feat *feat) {
        /* Code For Feat Goes Here */
        cout << "\nBegin Feature Descriptions" << endl;
        feat->listrule_->accept(this);

    }

    void XLEFeaturesParser::visitRuleA(RuleA *rulea) {
        /* Code For RuleA Goes Here */

        visitMyIdent(rulea->myident_);

        /* Convert Feature Name to INT*/
        map<string, unsigned int>::const_iterator findItem = mySM.SymbolMapper::symbol2int.find(rulea->myident_);

        if(findItem!=mySM.symbol2int.end()) { //Item was found

            TempStoreID = findItem->second;   //Get FEATURE ID INT value corresponding to a String
            Featsymbol2int[(string(rulea->myident_))] = TempStoreID; //Store the stoi hash table
            Featint2symbol[TempStoreID]=string(rulea->myident_); //Store reverse ^stoi hash table
        }

        else { //Item not found. Generate new ID for it and store into local table

            TempStoreID = mySM.SymbolMapper::getID(string(rulea->myident_));   //Get FEATURE ID INT value corresponding to a String
            Featsymbol2int[(string(rulea->myident_))] = TempStoreID; //Store the stoi hash table
            Featint2symbol[TempStoreID] = string(rulea->myident_); //Store reverse ^stoi hash table
        }

        /* INITIALIZING THE INTEGERS TO STRING AND BUILDING THE REVERSE HASH TABLE */

        TempStoreString = mySM.SymbolMapper::getLabel(TempStoreID); //Exact reverse of the above two steps
        Featint2symbol[TempStoreID] = TempStoreString;

        rulea->exp_->accept(this);

        /* PRINT THE FINAL TABLE */
        for(map<unsigned int,set<unsigned int> >::const_iterator loop=FinalTable.begin();loop!=FinalTable.end();loop++) {
            cout << loop->first;
            cout << "(" << mySM.SymbolMapper::getLabel(loop->first) << ")\t";
            for(set<unsigned int>::const_iterator loop2=loop->second.begin();loop2!=loop->second.end();loop2++) {
                cout << *loop2 << " ";
                cout << "(" << mySM.SymbolMapper::getLabel(*loop2) << ") ";
            }
            cout << endl;
        }

        cout << endl;

        //DAG Operations
        //TODO
        //Full Semantics

        for(map<unsigned int,set<unsigned int> >::const_iterator a=FinalTable.begin(); a!=FinalTable.end();a++) {

            set<unsigned int>::const_iterator temp=a->second.begin();
            unsigned int destNode = myDAG.DAG::addEdgeToAll(a->first,*temp);

            for(set<unsigned int>::const_iterator b=a->second.begin()++;b!=a->second.end();b++) {

                int count = 0;

                for(unsigned int i=0;i<mySM.SymbolMapper::getLabel(*b).length();i++) {

                    if (isupper(i))
                        count++;

                }

                if(count==mySM.SymbolMapper::getLabel(*b).length()) {

                    unsigned int currNode = myDAG.DAG::addEdgeToAll(a->first, *b);
                    myDAG.DAG::addEdgeToAll(a->first, currNode, *b);

                }

                else {

                        unsigned int currNode = myDAG.DAG::addEdgeToAll(a->first, *b);
                    }

                /*if(b==temp)
                    myDAG.DAG::addEdgeToAll(a->first,*b,*b);
                else
                    myDAG.DAG::addEdge(a->first,*b);*/
            }
        }

        myDAG.DAG::saveDOTtoFile(filename);

        category.clear();
        CategID.clear();
        ExpAny.clear();
        ExpAnyID.clear();
    }

    void XLEFeaturesParser::visitRuleAA(RuleAA *ruleaa) {
        /* Code For RuleAA Goes Here */

        visitMyIdent(ruleaa->myident_);

        /* Convert Feature Name to INT*/

        TempStoreID = mySM.SymbolMapper::getID(string(ruleaa->myident_));   //Get FEATURE ID INT value corresponding to a String
        Featsymbol2int[(string(ruleaa->myident_))] = TempStoreID; //Store the stoi hash table
        Featint2symbol[TempStoreID]=string(ruleaa->myident_); //Store reverse ^stoi hash table

        TempStoreString = mySM.SymbolMapper::getLabel(TempStoreID); //Exact reverse of the above two steps
        Featint2symbol[TempStoreID] = TempStoreString;

        ruleaa->exp_->accept(this);

        category.clear();
        CategID.clear();
        ExpAny.clear();
        ExpAnyID.clear();
    }

    void XLEFeaturesParser::visitRuleAE(RuleAE *ruleae) {
        /* Code For RuleAE Goes Here */

        visitMyIdent(ruleae->myident_);

        TempStoreID = mySM.SymbolMapper::getID(string(ruleae->myident_));   //Get FEATURE ID INT value corresponding to a String
        Featsymbol2int[(string(ruleae->myident_))] = TempStoreID; //Store the stoi hash table
        Featint2symbol[TempStoreID]=string(ruleae->myident_); //Store reverse ^stoi hash table

        TempStoreString = mySM.SymbolMapper::getLabel(TempStoreID); //Exact reverse of the above two steps
        Featint2symbol[TempStoreID] = TempStoreString;

        ruleae->exp_->accept(this);

        category.clear();
        CategID.clear();
        ExpAny.clear();
        ExpAnyID.clear();

    }

    void XLEFeaturesParser::visitRuleC(RuleC *rulec) {
        /* Code For RuleC Goes Here */
        visitMyIdent(rulec->myident_);

        TempStoreID = mySM.SymbolMapper::getID(string(rulec->myident_));   //Get FEATURE ID INT value corresponding to a String
        Featsymbol2int[(string(rulec->myident_))] = TempStoreID; //Store the stoi hash table
        Featint2symbol[TempStoreID]=string(rulec->myident_); //Store reverse ^stoi hash table

        TempStoreString = mySM.SymbolMapper::getLabel(TempStoreID); //Exact reverse of the above two steps
        Featint2symbol[TempStoreID] = TempStoreString;

        rulec->listexdisj_->accept(this);

        category.clear();
        CategID.clear();
        ExpAny.clear();
        ExpAnyID.clear();
    }

    void XLEFeaturesParser::visitRuleT(RuleT *rulet) {
        /* Code For RuleT Goes Here */
        visitMyIdent(rulet->myident_);

        TempStoreID = mySM.SymbolMapper::getID(string(rulet->myident_));   //Get FEATURE ID INT value corresponding to a String
        Featsymbol2int[(string(rulet->myident_))] = TempStoreID; //Store the stoi hash table
        Featint2symbol[TempStoreID]=string(rulet->myident_); //Store reverse ^stoi hash table

        TempStoreString = mySM.SymbolMapper::getLabel(TempStoreID); //Exact reverse of the above two steps
        Featint2symbol[TempStoreID] = TempStoreString;

        ExpAny.clear();
        ExpAnyID.clear();
        category.clear();
        CategID.clear();
    }

    void XLEFeaturesParser::visitRuleDP(RuleDP *ruledp) {
        /* Code For RuleDP Goes Here */
        cout << "\n o : : Meant for defining the OPTIMALITY ORDER" << endl;
    }

    void XLEFeaturesParser::visitExp(Exp *exp) {
        /* Code For Exp Goes Here */
        ExpAny.insert("%any");
        for(set<string>::const_iterator iter=ExpAny.begin() ; iter!=ExpAny.end() ; iter++) {
            TempStoreExpID = mySM.SymbolMapper::getID(*iter);
            categsymbol2int[*iter]=TempStoreExpID;
            categint2symbol[TempStoreExpID]=*iter;
            ExpAnyID.insert(TempStoreExpID);
        }

        FinalTable[TempStoreID] = ExpAnyID;
    }

    void XLEFeaturesParser::visitExpB(ExpB *expb) {
        /* Code For ExpB Goes Here */

        expb->listcats_->accept(this);

    }

    void XLEFeaturesParser::visitExpBA(ExpBA *expba) {
        /* Code For ExpBA Goes Here */

        expba->listsyms_->accept(this);

    }

    void XLEFeaturesParser::visitExpAC(ExpAC *expac) {
        /* Code For ExpAC Goes Here */

    }

    void XLEFeaturesParser::visitExpAD(ExpAD *expad) {
        /* Code For ExpAD Goes Here */

        expad->listcats_->accept(this);

    }

    void XLEFeaturesParser::visitExpDisj(ExpDisj *expdisj) {
        /* Code For ExpDisj Goes Here */

        expdisj->exp_->accept(this);

    }

    void XLEFeaturesParser::visitCats(Cats *cats) {
        /* Code For Cats Goes Here */

        visitMyIdent(cats->myident_);

        category.insert(cats->myident_);

        for(set<string>::const_iterator iterator1=category.begin(); iterator1!=category.end(); ++iterator1) {
            //TempStoreString = *iterator1; //Record the string inserted in the set
            TempStoreCategID = mySM.SymbolMapper::getID(*iterator1); //Get an ID for the string
            /*cout << *iterator1 << " ";
            cout << TempStoreCategID << endl;*/
            categsymbol2int[*iterator1]=TempStoreCategID;
            categint2symbol[TempStoreCategID]=*iterator1;
            CategID.insert(TempStoreCategID);   //Insert ID into another set
        }

        //cout << endl;

        FinalTable[TempStoreID] = CategID; //Populate the FINAL HASH TABLE with the feature & values in INT

        //PRINTING AIDE for FinalTable
        /*for(map<unsigned int,set<unsigned int> >::const_iterator a=FinalTable.begin(); a!=FinalTable.end();a++){
            cout << a->first << "\t" ;
            for(set<unsigned int>::const_iterator b=a->second.begin();b!=a->second.end();b++) {
                cout << *b << " " ;
            }
            cout << endl;
        }*/

    }

    void XLEFeaturesParser::visitSymbsP(SymbsP *symbsp) {
        /* Code For SymbsP Goes Here */

    }

    void XLEFeaturesParser::visitSymbsM(SymbsM *symbsm) {
        /* Code For SymbsM Goes Here */

    }

    void XLEFeaturesParser::visitSymbsPI(SymbsPI *symbspi) {
        /* Code For SymbsPI Goes Here */

        visitMyIdent(symbspi->myident_);

    }

    void XLEFeaturesParser::visitSymbsMI(SymbsMI *symbsmi) {
        /* Code For SymbsMI Goes Here */

        visitMyIdent(symbsmi->myident_);
    }

    /* LISTS */


    void XLEFeaturesParser::visitListRULE(ListRULE *listrule) {
        for (ListRULE::iterator i = listrule->begin(); i != listrule->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLEFeaturesParser::visitListEXDISJ(ListEXDISJ *listexdisj) {
        for (ListEXDISJ::iterator i = listexdisj->begin(); i != listexdisj->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLEFeaturesParser::visitListCATS(ListCATS *listcats) {
        for (ListCATS::iterator i = listcats->begin(); i != listcats->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLEFeaturesParser::visitListSYMS(ListSYMS *listsyms) {
        for (ListSYMS::iterator i = listsyms->begin(); i != listsyms->end(); ++i) {
            (*i)->accept(this);
        }
    }

    /* Data Types */

    void XLEFeaturesParser::visitMyIdent(MyIdent x) {
        /* Code for MyIdent Goes Here */
        //textBuffer = x;
    }

    void XLEFeaturesParser::visitInteger(Integer x) {
        /* Code for Integer Goes Here */
    }

    void XLEFeaturesParser::visitChar(Char x) {
        /* Code for Char Goes Here */
    }

    void XLEFeaturesParser::visitDouble(Double x) {
        /* Code for Double Goes Here */
    }

    void XLEFeaturesParser::visitString(String x) {
        /* Code for String Goes Here */
    }

    void XLEFeaturesParser::visitIdent(Ident x) {
        /* Code for Ident Goes Here */
    }

}
