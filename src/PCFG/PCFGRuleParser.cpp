/**
 * \class PCFGRuleParser
 * \file PCFGRuleParser.cpp
 *
 * \brief Provide a parser for PCFG rules.
 *
 * The code for this parser is indirectly generated from the specification of the BNF
 * grammar for PCFGs and the resulting parser class Skeleton.C generated by BNFC.
 *
 * \author Damir Cavar &lt;damir.cavar@gmail.com&gt;
 *
 * \version 0.3
 *
 * \date 2017/04/17 08:10:00
 *
 * \date Created on: Tue Oct 25 01:55:00 2016
 *
 * \copyright Copyright 2016-2017 by Damir Cavar
 *
 * \license{Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.}
 *
 * \see PCFGParserTest
 *
 * \note This code should be considered alpha.
 *
 * \bug None
 */


#include "PCFGRuleParser.h"


namespace pcfg {

    PCFGRuleParser::PCFGRuleParser(FLEWFST *newWfst) {
        wfst = newWfst;

        // Adds state 0 to the initially empty FST and make it the start state.
        startState = wfst->start_state;

        // targetState is 0 whenever we do not know it
        targetState = 0;
        fromState = startState;
    }


    void PCFGRuleParser::getRules(const char *str) {
        if (verbose)
            cout << "Parsing rule." << endl;
        Grammar *parse_tree = pGrammar(str);
        if (parse_tree) {
            parse_tree->accept(this);
        }
    }

    void PCFGRuleParser::visitGrammar(Grammar *t) {} //abstract class
    void PCFGRuleParser::visitRule(Rule *t) {} //abstract class
    void PCFGRuleParser::visitLHS(LHS *t) {} //abstract class
    void PCFGRuleParser::visitProb(Prob *t) {} //abstract class
    void PCFGRuleParser::visitDRHS(DRHS *t) {} //abstract class
    void PCFGRuleParser::visitRHS(RHS *t) {} //abstract class
    void PCFGRuleParser::visitDISJSTART(DISJSTART *t) {} //abstract class
    void PCFGRuleParser::visitDISJSTOP(DISJSTOP *t) {} //abstract class
    void PCFGRuleParser::visitBRSTART(BRSTART *t) {} //abstract class
    void PCFGRuleParser::visitBRSTOP(BRSTOP *t) {} //abstract class
    void PCFGRuleParser::visitARROW(ARROW *t) {} //abstract class
    void PCFGRuleParser::visitCRHS(CRHS *t) {} //abstract class

    void PCFGRuleParser::visitGram(Gram *gram) {
        gram->listrule_->accept(this);
    }


    void PCFGRuleParser::visitRul(Rul *rul) {
        // int tmpStartState = wfst->start_state;

        // targetState is 0 whenever we do not know it
        targetState = 0;
        fromState = startState;

        rul->prob_->accept(this);
        rul->lhs_->accept(this);
        rul->arrow_->accept(this);
        rul->listcrhs_->accept(this);

        // increment rule counter
        ++countRules;

        // append the transitions with the LHS-symbol(s)
        for (const auto &symb : LHSBuffer) {
            targetState = wfst->addState();
            wfst->addArc(fromState, targetState, wfst->epsilon, symb, wfst->defaultWeight);
            fromState = targetState;
            targetState = 0;
        }
        // empty the LHSBuffer
        LHSBuffer.clear();

        // set fromState to startState for new rule
        wfst->setFinalState(fromState, ruleWeight);
        fromState = startState;

        // wfst->removeEpsilon();
        // wfst->minimize();
    }


    void PCFGRuleParser::visitERul(ERul *erul) {}


    void PCFGRuleParser::visitLhsS(LhsS *lhss) {
        visitIdent(lhss->ident_);

        // add LHS-symbol to buffer
        LHSBuffer.push_back(wfst->getSymbolID(lhss->ident_));
    }


    void PCFGRuleParser::visitProbS(ProbS *prob_s) {
        ruleWeight = prob_s->double_;
        visitDouble(prob_s->double_);
    }


    void PCFGRuleParser::visitArrow1(Arrow1 *arrow) {}

    void PCFGRuleParser::visitArrow2(Arrow2 *arrow) {}

    void PCFGRuleParser::visitArrow4(Arrow4 *arrow) {}

    void PCFGRuleParser::visitArrow3(Arrow3 *arrow) {}


    void PCFGRuleParser::visitRhsDisjSyms(RhsDisjSyms *rhs_disj_syms) {
        disjunctionGroup = true;
        rhs_disj_syms->listrhs_->accept(this);
        disjunctionGroup = false;
    }


    void PCFGRuleParser::visitRhsSymbol(RhsSymbol *rhssymbol) {
        visitIdent(rhssymbol->ident_);
        // create a new target state
        lastSymbol = wfst->getSymbolID(rhssymbol->ident_);
        lastWeight = wfst->defaultWeight;
        targetState = wfst->addArc(fromState, lastSymbol, lastWeight);
        oneButLastInGroup = fromState;
        fromState = targetState;
        targetState = 0;
    }


    void PCFGRuleParser::visitRhsSymbolP(RhsSymbolP *rhssymbolp) {
        visitIdent(rhssymbolp->ident_);
        // create a new target state
        lastSymbol = wfst->getSymbolID(rhssymbolp->ident_);
        lastWeight = wfst->defaultWeight;
        targetState = wfst->addArc(fromState, lastSymbol, lastWeight);
        oneButLastInGroup = fromState;
        wfst->addArc(targetState, targetState, lastSymbol, wfst->epsilon, lastWeight);
        fromState = targetState;
        targetState = 0;
    }


    void PCFGRuleParser::visitRhsSymbolA(RhsSymbolA *rhssymbola) {
        visitIdent(rhssymbola->ident_);
        lastSymbol = wfst->getSymbolID(rhssymbola->ident_);
        lastWeight = wfst->defaultWeight;
        targetState = wfst->addArc(fromState, wfst->epsilon, wfst->defaultWeight);
        wfst->addArc(targetState, targetState, lastSymbol, wfst->epsilon, wfst->defaultWeight);
        oneButLastInGroup = fromState;
        fromState = targetState;
        targetState = 0;
    }


    void PCFGRuleParser::visitDisjStart(DisjStart *disjstart) {
        // starting disjunction
        // adding a final state for disjunction groups
        disjunctionGroup = true;
        disjunctionFinalState = wfst->addState();
        disjunctionStartState = fromState;
    }


    void PCFGRuleParser::visitDisjStop(DisjStop *disjstop) {
        // make the final state of disjunction the new fromState
        fromState = disjunctionFinalState;
        disjunctionFinalState = 0;
        disjunctionStartState = 0;
        targetState = 0;
        disjunctionGroup = false;
    }


    void PCFGRuleParser::visitRhsDisj(RhsDisj *rhs_disj) {
        rhs_disj->disjstart_->accept(this);
        rhs_disj->listdrhs_->accept(this);
        rhs_disj->disjstop_->accept(this);
    }


    void PCFGRuleParser::visitRhsTerminal(RhsTerminal *rhsterminal) {
        visitString(rhsterminal->string_);
        const int symbol = wfst->getSymbolID(rhsterminal->string_);

        targetState = wfst->addArc(fromState, symbol, wfst->defaultWeight);
        oneButLastInGroup = fromState;
        fromState = targetState;
        targetState = 0;
    }


    void PCFGRuleParser::visitRhsEpsilon(RhsEpsilon *rhsepsilon) {
        targetState = wfst->addArc(fromState, wfst->epsilon, wfst->defaultWeight);
        oneButLastInGroup = fromState;
        fromState = targetState;
        targetState = 0;
    }


    void PCFGRuleParser::visitRhsBr(RhsBr *rhs_br) {
        groupingStart = fromState;
        rhs_br->brstart_->accept(this);
        rhs_br->listrhs_->accept(this);
        rhs_br->brstop_->accept(this);

        // add epsilon transition to fromState
        wfst->addArc(groupingStart, fromState, wfst->epsilon, wfst->epsilon, wfst->defaultWeight);
    }


    void PCFGRuleParser::visitRhsBrP(RhsBrP *rhs_br_p) {
        rhs_br_p->brstart_->accept(this);
        rhs_br_p->listrhs_->accept(this);
        groupingStart = fromState;
        rhs_br_p->listrhs_->accept(this);
        rhs_br_p->brstop_->accept(this);

        // remove oneButLastInGroup, fromState, lastSymbol, lastWeight
        wfst->delArc(oneButLastInGroup, fromState, lastSymbol, wfst->epsilon, lastWeight);
        // add oneButLastInGroup, groupingStart, lastSymbol, lastWeight
        wfst->addArc(oneButLastInGroup, groupingStart, lastSymbol, wfst->epsilon, lastWeight);

        fromState = groupingStart;
        targetState = 0;
    }


    void PCFGRuleParser::visitRhsBrA(RhsBrA *rhs_br_a) {
        if (fromState == wfst->start_state) {
            targetState = wfst->addArc(fromState, wfst->epsilon, wfst->defaultWeight);
            fromState = targetState;
            targetState = 0;
        }

        rhs_br_a->brstart_->accept(this);
        groupingStart = fromState;
        rhs_br_a->listrhs_->accept(this);
        rhs_br_a->brstop_->accept(this);

        // remove oneButLastInGroup, fromState, lastSymbol, lastWeight
        wfst->delArc(oneButLastInGroup, fromState, lastSymbol, wfst->epsilon, lastWeight);
        // add oneButLastInGroup, groupingStart, lastSymbol, lastWeight
        wfst->addArc(oneButLastInGroup, groupingStart, lastSymbol, wfst->epsilon, lastWeight);

        fromState = groupingStart;
        targetState = 0;
    }


    void PCFGRuleParser::visitRhsSym(RhsSym *rhs_sym) {
        rhs_sym->rhs_->accept(this);
    }


    void PCFGRuleParser::visitBrStart(BrStart *brstart) {
        bracketedGroup = true;
    }


    void PCFGRuleParser::visitBrStop(BrStop *brstop) {
        bracketedGroup = false;
    }


    void PCFGRuleParser::visitListRule(ListRule *listrule) {
        for (ListRule::iterator i = listrule->begin(); i != listrule->end(); ++i) {
            (*i)->accept(this);
        }
    }


    void PCFGRuleParser::visitListRHS(ListRHS *listrhs) {
        for (ListRHS::iterator i = listrhs->begin(); i != listrhs->end(); ++i) {
            (*i)->accept(this);
        }
        if (disjunctionGroup) {
            tuple<int, int, int, int, double> last = wfst->last_transition;
            if (get<1>(last) != 0) {
                // are first and last the same? = recursive transition
                if (get<0>(last) == get<1>(last)) {
                    // then add empty transition
                    if (disjunctionFinalState == disjunctionStartState) {
                        // we did not set disjunctionFinalState yet
                        disjunctionFinalState = wfst->addArc(fromState, wfst->epsilon, wfst->defaultWeight);
                    } else {
                        wfst->addArc(fromState, disjunctionFinalState, wfst->epsilon, wfst->epsilon, wfst->defaultWeight);
                    }
                } else {
                    if (disjunctionFinalState == disjunctionStartState) {
                        // we did not set disjunctionFinalState yet
                        disjunctionFinalState = get<1>(last);
                    } else {
                        // there was some last transition, delete it
                        wfst->delArc(get<0>(last), get<1>(last), get<2>(last), get<3>(last), get<4>(last));
                        // there was some last transition, set new
                        wfst->addArc(get<0>(last), disjunctionFinalState, get<2>(last), get<3>(last), get<4>(last));
                    }
                }
            }
            fromState = disjunctionStartState;
            targetState = 0;
        }
    }


    void PCFGRuleParser::visitListCRHS(ListCRHS *list_crhs) {
        for (ListCRHS::iterator i = list_crhs->begin(); i != list_crhs->end(); ++i) {
            (*i)->accept(this);
        }
    }


    void PCFGRuleParser::visitListDRHS(ListDRHS *listdrhs) {
        for (ListDRHS::iterator i = listdrhs->begin(); i != listdrhs->end(); ++i) {
            (*i)->accept(this);
        }
    }


    void PCFGRuleParser::visitInteger(Integer x) { }


    void PCFGRuleParser::visitChar(Char x) { }


    void PCFGRuleParser::visitDouble(Double x) { }


    void PCFGRuleParser::visitString(String x) { }


    void PCFGRuleParser::visitIdent(Ident x) { }

}