/**
 * \class XLERuleParser
 * \file XLERuleParser.cpp
 *
 * \brief Provide a parser for XLE RULES section settings.
 *
 * The code for this parser is indirectly generated from the specification of the BNF
 * grammar for XLE RULES and the resulting parser class Skeleton.C generated by BNFC.
 *
 * \author Damir Cavar &lt;dcavar@iu.edu&gt;
 *
 * \version 0.2
 *
 * \date 2017/03/26 14:17:00
 *
 * \date Created on: Tue Oct 25 01:55:00 2016
 *
 * \copyright Copyright 2016-2017 by Damir Cavar
 *
 * \license{Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.}
 *
 * \see XLERuleParserTest
 *
 * \note This code should be considered alpha.
 *
 * \bug None
 */



#include "XLERuleParser.h"

namespace xlerules {

    XLERuleParser::XLERuleParser(FLEWFST *newWfst) {
        wfst = newWfst;

        // Adds state 0 to the initially empty FST and make it the start state.
        startState = wfst->start_state;

        // targetState is 0 whenever we do not know it
        targetState = 0;
        fromState = startState;
    }

    XLERuleParser::~XLERuleParser() {}

    void XLERuleParser::getRules(const char *str) {
        GRAMMAR *parse_tree = pGRAMMAR(str);
        if (parse_tree) {
            parse_tree->accept(this);
        }
    }

    void XLERuleParser::visitGRAMMAR(GRAMMAR *t) {} //abstract class
    void XLERuleParser::visitRULE(RULE *t) {} //abstract class
    void XLERuleParser::visitLHS(LHS *t) {} //abstract class
    void XLERuleParser::visitRHSSYMBOL(RHSSYMBOL *t) {} //abstract class
    void XLERuleParser::visitRHSSYMB(RHSSYMB *t) {} //abstract class
    void XLERuleParser::visitEPSILONSYMB(EPSILONSYMB *t) {} //abstract class
    void XLERuleParser::visitRHS(RHS *t) {} //abstract class
    void XLERuleParser::visitDRHS(DRHS *t) {} //abstract class
    void XLERuleParser::visitSCHEMA(SCHEMA *t) {} //abstract class
    void XLERuleParser::visitDSYMBOL(DSYMBOL *t) {} //abstract class
    void XLERuleParser::visitSYMBOL(SYMBOL *t) {} //abstract class
    void XLERuleParser::visitVALUE(VALUE *t) {} //abstract class


    void XLERuleParser::visitGrammar(Grammar *grammar) {
        grammar->listrule_->accept(this);
    }

    void XLERuleParser::visitRule(Rule *rule) {
        if (verbose)
            cout << "in visitRuleS " << endl;
        equalRule = false;
        /* Code For RuleS Goes Here */
        targetState = 0;
        fromState = startState;

        rule->lhs_->accept(this);
        rule->listrhs_->accept(this);

        // increment number of rules
        ++countRules;

        // append the transitions with the LHS-symbol(s)
        for (const auto &symb : LHSBuffer) {
            targetState = wfst->addState();
            wfst->addArc(fromState, targetState, wfst->epsilon, symb, wfst->defaultWeight);
            fromState = targetState;
            targetState = 0;
        }
        // empty the LHSBuffer
        LHSBuffer.clear();

        // set fromState to startState for new rule
        wfst->setFinalState(fromState, wfst->defaultWeight);
        fromState = startState;

        // wfst->removeEpsilon();
        // wfst->minimize();
    }

    void XLERuleParser::visitLHSSymbol(LHSSymbol *lhs_symbol) {
        visitIdent(lhs_symbol->ident_);
        // add LHS-symbol to buffer
        LHSBuffer.push_back(wfst->getSymbolID(lhs_symbol->ident_));
    }

    void XLERuleParser::visitSymbol(Symbol *symbol) {
        if (verbose)
            cout << "in visitSymbol" << endl;
        visitIdent(symbol->ident_);
    }


    void XLERuleParser::visitRHSSymbolString(RHSSymbolString *rhs_symbol_string) {
        if (verbose)
            cout << "visitRHSSymbolString: " << rhs_symbol_string->ident_ << endl;
        visitIdent(rhs_symbol_string->ident_);
        lastSymbol = wfst->getSymbolID(rhs_symbol_string->ident_);
        lastWeight = wfst->defaultWeight;
        targetState = wfst->addArc(fromState, lastSymbol, lastWeight);
        oneButLastInGroup = fromState;
        if (bracketedGroup) { // this is optional so
            if (verbose)
            cout << "visitRHSSymbolString: " << "bracketedGroup" << endl;
            // add epsilon transition to fromState
            wfst->addArc(groupingStart, targetState, wfst->epsilon, wfst->epsilon, wfst->defaultWeight);
        }
        //else if (disjunctionGroup) {
        //
        //}
        fromState = targetState;
        targetState = 0;
    }

/*
    void XLERuleParser::visitRHSSymbolAst(RHSSymbolAst *rhs_symbol_ast) {
        cout << "visitRHSSymbolAstString: " << rhs_symbol_ast->ident_ << endl;
        if (fromState == wfst->start_state) {
            targetState = wfst->addArc(fromState, wfst->epsilon, wfst->defaultWeight);
            fromState = targetState;
            targetState = 0;
        }
        visitIdent(rhs_symbol_ast->ident_);
        lastSymbol = wfst->getSymbolID(rhs_symbol_ast->ident_);
        lastWeight = wfst->defaultWeight;
        targetState = wfst->addArc(fromState, lastSymbol, lastWeight);
        wfst->addArc(fromState, targetState, wfst->epsilon, wfst->epsilon, lastWeight);
        wfst->addArc(targetState, targetState, lastSymbol, wfst->epsilon, lastWeight);
        fromState = targetState;
        targetState = 0;
    }


*/

/*
    void XLERuleParser::visitRHSDisjunctionSymbols(RHSDisjunctionSymbols *rhs_disjunction_symbols) {
        rhs_disjunction_symbols->rhssymbol_->accept(this);
        // create epsilon transition to disjunctionFinalState
        cout << " in visitRHSDisjunctionSymbols " << endl;
        // cout << lastSymbol << " " << lastWeight << endl;
        if (disjunctionFinalState == 0) {
            disjunctionFinalState = fromState;
        } else {
            wfst->addArc(fromState, disjunctionFinalState, wfst->epsilon, wfst->epsilon, wfst->defaultWeight);
        }
        fromState = disjunctionStartState;
        targetState = 0;
        cout << "after visitRHSDisjunctionSymbols " << endl;
    }

    void XLERuleParser::visitListORHS(ListORHS *list_orhs) {
        cout << "disjunction list start" << endl;
        disjunctionGroup = true;
        // disjunctionFinalState = wfst->addState();
        disjunctionStartState = fromState;
        for (ListORHS::iterator i = list_orhs->begin(); i != list_orhs->end(); ++i) {
            (*i)->accept(this);
        }
        cout << "disjunction list end" << endl;
        if (disjunctionFinalState > 0) {
            fromState = disjunctionFinalState;
        }
        targetState = 0;
        disjunctionGroup = false;
    }
*/

    void XLERuleParser::visitRHSSymbolAst(RHSSymbolAst *rhs_symbol_ast) {
        rhs_symbol_ast->rhssymb_->accept(this);
    }

    void XLERuleParser::visitRHSSymbol(RHSSymbol *rhs_symbol) {
        rhs_symbol->rhssymb_->accept(this);
    }

    //void XLERuleParser::visitRHSSymbolString(RHSSymbolString *rhs_symbol_string) {
    //    visitIdent(rhs_symbol_string->ident_);
    //}

    void XLERuleParser::visitRHSSymbolEpsilon(RHSSymbolEpsilon *rhs_symbol_epsilon) {}

    void XLERuleParser::visitRHSSymbolEpsUpSymb(RHSSymbolEpsUpSymb *rhs_symbol_eps_up_symb) {
        rhs_symbol_eps_up_symb->epsilonsymb_->accept(this);
        rhs_symbol_eps_up_symb->symbol_->accept(this);
    }

    void XLERuleParser::visitRHSSymbolEpsUpSymbEnd(RHSSymbolEpsUpSymbEnd *rhs_symbol_eps_up_symb_end) {
        rhs_symbol_eps_up_symb_end->epsilonsymb_->accept(this);
        rhs_symbol_eps_up_symb_end->symbol_->accept(this);
    }

    void XLERuleParser::visitRHSSymbolOnly(RHSSymbolOnly *rhs_symbol_only) {
        rhs_symbol_only->rhssymbol_->accept(this);
    }

    void XLERuleParser::visitRHSFunctionalSchema(RHSFunctionalSchema *rhs_functional_schema) {
        rhs_functional_schema->rhssymbol_->accept(this);
        rhs_functional_schema->listschema_->accept(this);
    }

    void XLERuleParser::visitRHSFunctionalSchemaEnd(RHSFunctionalSchemaEnd *rhs_functional_schema_end) {
        rhs_functional_schema_end->rhssymbol_->accept(this);
        rhs_functional_schema_end->listschema_->accept(this);
    }

    void XLERuleParser::visitRHSOptionalSymbol(RHSOptionalSymbol *rhs_optional_symbol) {
        rhs_optional_symbol->rhssymbol_->accept(this);
    }

    void XLERuleParser::visitRHSOptional(RHSOptional *rhs_optional) {
        rhs_optional->rhssymbol_->accept(this);
        rhs_optional->listschema_->accept(this);
    }

    void XLERuleParser::visitRHSDisjunction(RHSDisjunction *rhs_disjunction) {
        rhs_disjunction->listdrhs_->accept(this);
    }

    void XLERuleParser::visitDRHSSymbol(DRHSSymbol *drhs_symbol) {
        drhs_symbol->rhssymbol_->accept(this);
    }

    void XLERuleParser::visitDRHSFunctionalSchema(DRHSFunctionalSchema *drhs_functional_schema) {
        drhs_functional_schema->rhssymbol_->accept(this);
        drhs_functional_schema->listschema_->accept(this);
    }

    void XLERuleParser::visitDRHSOptionalSymbol(DRHSOptionalSymbol *drhs_optional_symbol) {
        drhs_optional_symbol->rhssymbol_->accept(this);
    }

    void XLERuleParser::visitDRHSOptional(DRHSOptional *drhs_optional) {
        drhs_optional->rhssymbol_->accept(this);
        drhs_optional->listschema_->accept(this);
    }

    void XLERuleParser::visitSchemaUpDown(SchemaUpDown *schema_up_down) { }

    void XLERuleParser::visitSchemaFeatUpDown(SchemaFeatUpDown *schema_feat_up_down) {
        schema_feat_up_down->symbol_->accept(this);
    }

    void XLERuleParser::visitSchemaFeatDownVal(SchemaFeatDownVal *schema_feat_down_val) {
        schema_feat_down_val->symbol_->accept(this);
        schema_feat_down_val->value_->accept(this);
    }

    void XLERuleParser::visitSchemaXcompUpSetDown(SchemaXcompUpSetDown *schema_xcomp_up_set_down) {
        schema_xcomp_up_set_down->symbol_->accept(this);
        schema_xcomp_up_set_down->listdsymbol_->accept(this);
    }

    void XLERuleParser::visitSchemaDownSetUp(SchemaDownSetUp *schema_down_set_up) {
        schema_down_set_up->symbol_->accept(this);
    }

    void XLERuleParser::visitSchemaDisjSymb(SchemaDisjSymb *schema_disj_symb) {
        visitIdent(schema_disj_symb->ident_);
    }

    //void XLERuleParser::visitSymbol(Symbol *symbol) {
    //    visitIdent(symbol->ident_);
    //}

    void XLERuleParser::visitValue(Value *value) {
        visitIdent(value->ident_);
    }


    void XLERuleParser::visitListRULE(ListRULE *list_rule) {
        for (ListRULE::iterator i = list_rule->begin(); i != list_rule->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListRHS(ListRHS *list_rhs) {
        for (ListRHS::iterator i = list_rhs->begin(); i != list_rhs->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListSCHEMA(ListSCHEMA *list_schema) {
        for (ListSCHEMA::iterator i = list_schema->begin(); i != list_schema->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListDRHS(ListDRHS *list_drhs) {
        for (ListDRHS::iterator i = list_drhs->begin(); i != list_drhs->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListDSYMBOL(ListDSYMBOL *list_dsymbol) {
        for (ListDSYMBOL::iterator i = list_dsymbol->begin(); i != list_dsymbol->end(); ++i) {
            (*i)->accept(this);
        }
    }


    void XLERuleParser::visitInteger(Integer x) {
        /* Code for Integer Goes Here */
    }

    void XLERuleParser::visitChar(Char x) {
        /* Code for Char Goes Here */
    }

    void XLERuleParser::visitDouble(Double x) {
        /* Code for Double Goes Here */
    }

    void XLERuleParser::visitString(String x) {
        /* Code for String Goes Here */
    }

    void XLERuleParser::visitIdent(Ident x) {
        /* Code for Ident Goes Here */
    }

}
