/**
 * \class XLERuleParser
 * \file XLERuleParser.cpp
 *
 * \brief Provide a parser for XLE RULES section settings.
 *
 * The code for this parser is indirectly generated from the specification of the BNF
 * grammar for XLE RULES and the resulting parser class Skeleton.C generated by BNFC.
 *
 * \author Damir Cavar &lt;dcavar@iu.edu&gt;
 *
 * \version 0.1
 *
 * \date 2016/10/25 01:53:00
 *
 * \date Created on: Tue Oct 25 01:55:00 2016
 *
 * \copyright Copyright 2016 by Damir Cavar
 *
 * \license{Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.}
 *
 * \see XLERuleParserTest
 *
 * \note This code should be considered alpha.
 *
 * \bug None
 */



#include <limits.h>
#include "XLERuleParser.h"

namespace xlerules {


    XLERuleParser::XLERuleParser() {
        // delete myFST;
    }

    XLERuleParser::~XLERuleParser() {
        // myFST = new FLEWFST();
    }

    void XLERuleParser::visitGrammar(Grammar *grammar) {
        /* Code For Grammar Goes Here */

        //if (verbose)
        //    cout << "Visiting Grammar." << endl;

        grammar->listrule_->accept(this);

        //if (verbose)
        //    cout << "Leaving Grammar." << endl;
    }


    void XLERuleParser::visitRuleS(RuleS *rules) {
        /* Code For RuleS Goes Here */
        //if (verbose)
        //    cout << "Visiting RuleS." << endl;

        rules->lhs_->accept(this);
        rules->listrhs_->accept(this);

        // increment number of rules
        ++count_rules;

        //unsigned long prev_state = myFST->start_state;
        //unsigned long newState = myFST->start_state;
        //unsigned long symbol = myFST->FLEEPSILON;
        unsigned int type = SYMBOL_TYPE_PLAIN;
        //unsigned long outsym = myFST->FLEEPSILON;
        bool last = false;
        double weight = 1.0;

        for (unsigned long i = 0; i < myRHS.size(); i++) {
            // create state and arc
            //symbol = myRHS[i].first;
            type = myRHS[i].second;
            if (i == (myRHS.size() - 1))
                last = true;
            if (type == SYMBOL_TYPE_PLAIN) {
                if (last) {
                    //prev_state = myFST->addArc(prev_state, symbol, myLHS, weight);
                    //myFST->setFinalState(prev_state); // declare final state
                }// else
                //prev_state = myFST->addArc(prev_state, symbol, myFST->FLEEPSILON, weight);
            } else if (type == SYMBOL_TYPE_AST) {
                if (last) {
                    //myFST->addArc(prev_state, prev_state, symbol, myFST->FLEEPSILON, weight);
                    //newState = myFST->addArc(prev_state, myFST->FLEEPSILON, myLHS, weight);
                    //prev_state = newState;
                    //myFST->setFinalState(prev_state); // declare final state
                } //else
                //myFST->addArc(prev_state, prev_state, symbol, myFST->FLEEPSILON, weight);
            } else if (type == SYMBOL_TYPE_OPT) {
                //myFST->reverseSymbolMap();
                //cout << "Optional symbol: " << myFST->getSymbol(symbol) << " " << symbol << endl;
                if (last) {
                    //newState = myFST->addArc(prev_state, symbol, myLHS, weight);
                    //myFST->addArc(prev_state, newState, myFST->FLEEPSILON, myLHS, weight);
                    //prev_state = newState;
                    //myFST->setFinalState(prev_state); // declare final state
                } else {
                    //newState = myFST->addArc(prev_state, symbol, myFST->FLEEPSILON, weight);
                    //myFST->addArc(prev_state, newState, myFST->FLEEPSILON, myFST->FLEEPSILON, weight);
                    //prev_state = newState;
                }
            } else if (type == SYMBOL_TYPE_DISJUNCTION) {
                //newState = myFST->addState();

                vector<unsigned long> symbols;
                // loop over subsequent states and make them parallel arcs if disjoint
                for (unsigned long j = i; j < myRHS.size(); j++) {
                    if (myRHS[j].second == SYMBOL_TYPE_DISJUNCTION) {
                        symbols.push_back(myRHS[j].first);
                        ++i;
                    } else {
                        // if delimiter following, skip it
                        if (myRHS[j].first == ULONG_MAX)
                            ++i;
                        break;
                    }
                }
                // determine the output symbol
                if (i >= (myRHS.size() - 1)) { // if last state
                    //myFST->setFinalState(newState);
                    //outsym = myLHS;
                } else {
                    //outsym = myFST->FLEEPSILON;
                }
                // write out arcs
                for (auto sym : symbols) {
                    //myFST->addArc(prev_state, newState, sym, outsym, weight);
                }
            }
        }
        myLHS = 0;
        myRHS.clear();
        //if (verbose)
        //    cout << "Leaving RuleS." << endl;
    }


    void XLERuleParser::visitLHSSymbolString(LHSSymbolString *lhssymbolstring) {
        /* Code For LHSSymbolString Goes Here */

        //myLHS = myFST->addSymbol(lhssymbolstring->ident_, false);
        //if (verbose)
        //    cout << "Left hand side symbol: " << lhssymbolstring->ident_ << " with ID: " << myLHS << endl;
        visitIdent(lhssymbolstring->ident_);
    }


    void XLERuleParser::visitRHSSymbolString(RHSSymbolString *rhssymbolstring) {
        /* Code For RHSSymbolString Goes Here */
        bool epsilon = false;
        if (rhssymbolstring->ident_ == "e") {
            epsilon = true;
            //myRHS.push_back(make_pair(myFST->EPSILON, SYMBOL_TYPE_PLAIN));
        }

        //if (optionalSymbol) {
        //    myRHS.push_back(make_pair(myFST->addSymbol(rhssymbolstring->ident_, false), SYMBOL_TYPE_OPT));
        //} else if (discunjctionSymbol) {
        // cout << "Found disjunction symbol" << rhssymbolstring->ident_ << endl;
        //    myRHS.push_back(make_pair(myFST->addSymbol(rhssymbolstring->ident_, false), SYMBOL_TYPE_DISJUNCTION));
        //} else {
        //    if (epsilon)
        //        myRHS.push_back(make_pair(myFST->FLEEPSILON, SYMBOL_TYPE_PLAIN));
        //    else
        //        myRHS.push_back(make_pair(myFST->addSymbol(rhssymbolstring->ident_, false), SYMBOL_TYPE_PLAIN));
        //}

        //if (verbose)
        //    cout << "Right hand side symbol: " << rhssymbolstring->ident_ << " with ID: " <<
        //    myRHS[myRHS.size() - 1].first << endl;
        visitIdent(rhssymbolstring->ident_);
    }


    void XLERuleParser::visitRHSSymbolAstString(RHSSymbolAstString *rhssymbolaststring) {
        // set previousSymbolType to SYMBOL_TYPE_AST
        //myRHS.push_back(make_pair(myFST->addSymbol(rhssymbolaststring->ident_, false), SYMBOL_TYPE_AST));
        //if (verbose)
        //    cout << "Right hand side Kleene-starred symbol: " << rhssymbolaststring->ident_
        //    << " with ID: " << myRHS[myRHS.size() - 1].first << endl;
        visitIdent(rhssymbolaststring->ident_);
    }


    void XLERuleParser::getRules(const char *str) { // }, FLEWFST &myNewFST) {
        //if (verbose)
        //    cout << "Parsing rule." << endl;
        //myFST = &myNewFST;
        //myLHS = myFST->FLEEPSILON; /*!< ID of the last state in myFST */
        //lastState = myFST->start_state;
        //lastTransition = make_pair(make_pair((unsigned long)0, (unsigned long)0), make_tuple((unsigned long)0, (unsigned long)0, (double)0.0));

        // change the returned type or the way it is constructed!
        // TODO
        GRAMMAR *parse_tree = pGRAMMAR(str);
        if (parse_tree) {
            parse_tree->accept(this);
        }
    }


    void XLERuleParser::visitRHSSymbolOptional(RHSSymbolOptional *rhs_symbol_optional) {
        /* Code For RHSSymbolOptional Goes Here */

        optionalSymbol = true;
        //if (verbose)
        //    cout << "Optional RHS-symbols started." << endl;
        rhs_symbol_optional->rhssymbol_->accept(this);
        //if (verbose)
        //    cout << "Optional RHS-symbols ended." << endl;
        optionalSymbol = false;
    }


    void XLERuleParser::visitRHSymbolsDisjunction(RHSymbolsDisjunction *rh_symbols_disjunction) {
        /* Code For RHSymbolsDisjunction Goes Here */

        //if (verbose)
        //    cout << "RHS symbols disjunction started." << endl;
        discunjctionSymbol = true;
        rh_symbols_disjunction->listorhs_->accept(this);
        discunjctionSymbol = false;
        // push on symbol stack to delimit DISJUNCTION processing
        // assign ULONG_MAX to the delimiter for disjunctions
        myRHS.push_back(make_pair(ULONG_MAX, SYMBOL_TYPE_PLAIN));
        //if (verbose)
        //    cout << "RHS symbols disjunction ended." << endl;
    }


    void XLERuleParser::visitRHSSymbolFunctionalSchemaOptional(
            RHSSymbolFunctionalSchemaOptional *rhs_symbol_functional_schema_optional) {
        /* Code For RHSSymbolFunctionalSchemaOptional Goes Here */

        // hit a disjunction of RHS-Symbols
        // all start and end at the same state
        optionalSymbol = true;
        rhs_symbol_functional_schema_optional->rhssymbol_->accept(this);
        rhs_symbol_functional_schema_optional->listschem_->accept(this);
        optionalSymbol = false;

    }


    void XLERuleParser::visitGRAMMAR(GRAMMAR *t) {} //abstract class
    void XLERuleParser::visitRULE(RULE *t) {} //abstract class
    void XLERuleParser::visitRULEES(RULEES *t) {} //abstract class
    void XLERuleParser::visitLHS(LHS *t) {} //abstract class
    void XLERuleParser::visitSYMBOL(SYMBOL *t) {} //abstract class
    void XLERuleParser::visitRHSSYMBOL(RHSSYMBOL *t) {} //abstract class
    void XLERuleParser::visitRHS(RHS *t) {} //abstract class
    void XLERuleParser::visitORHS(ORHS *t) {} //abstract class
    void XLERuleParser::visitSCHEM(SCHEM *t) {} //abstract class
    void XLERuleParser::visitUP(UP *t) {} //abstract class
    void XLERuleParser::visitDOWN(DOWN *t) {} //abstract class
    void XLERuleParser::visitLEFTSCHEMA(LEFTSCHEMA *t) {} //abstract class
    void XLERuleParser::visitSORHS(SORHS *t) {} //abstract class
    void XLERuleParser::visitSSYMBOL(SSYMBOL *t) {} //abstract class
    void XLERuleParser::visitRIGHTSCHEMA(RIGHTSCHEMA *t) {} //abstract class



    void XLERuleParser::visitRuleEndSymbol(RuleEndSymbol *rule_end_symbol) {
        /* Code For RuleEndSymbol Goes Here */
    }


    void XLERuleParser::visitSymbol(Symbol *symbol) {
        /* Code For Symbol Goes Here */

        visitIdent(symbol->ident_);
    }

    void XLERuleParser::visitSymbolAst(SymbolAst *symbol_ast) {
        /* Code For SymbolAst Goes Here */

        visitIdent(symbol_ast->ident_);
    }


    void XLERuleParser::visitRHSSymbol(RHSSymbol *rhs_symbol) {
        /* Code For RHSSymbol Goes Here */
        rhs_symbol->rhssymbol_->accept(this);
    }

    void XLERuleParser::visitRHSSymbolFunctionalSchema(RHSSymbolFunctionalSchema *rhs_symbol_functional_schema) {
        /* Code For RHSSymbolFunctionalSchema Goes Here */

        rhs_symbol_functional_schema->rhssymbol_->accept(this);
        rhs_symbol_functional_schema->listschem_->accept(this);

    }

    void XLERuleParser::visitRHSSymbolFunctionalSchemaMult(
            RHSSymbolFunctionalSchemaMult *rhs_symbol_functional_schema_mult) {
        /* Code For RHSSymbolFunctionalSchemaMult Goes Here */

        rhs_symbol_functional_schema_mult->rhssymbol_->accept(this);
        rhs_symbol_functional_schema_mult->listschem_->accept(this);
        rhs_symbol_functional_schema_mult->listrhs_->accept(this);

    }


    void XLERuleParser::visitRHSDisjunctionSymbols(RHSDisjunctionSymbols *rhs_disjunction_symbols) {
        /* Code For RHSDisjunctionSymbols Goes Here */
        rhs_disjunction_symbols->rhssymbol_->accept(this);

    }

    void XLERuleParser::visitSchema(Schema *schema) {
        /* Code For Schema Goes Here */

        schema->leftschema_->accept(this);
        schema->rightschema_->accept(this);

    }

    void XLERuleParser::visitSchemaSimple(SchemaSimple *schema_simple) {
        /* Code For SchemaSimple Goes Here */

        schema_simple->leftschema_->accept(this);

    }

    void XLERuleParser::visitUp(Up *up) {
        /* Code For Up Goes Here */


    }

    void XLERuleParser::visitDown(Down *down) {
        /* Code For Down Goes Here */


    }

    void XLERuleParser::visitLSchemaUP(LSchemaUP *l_schema_up) {
        /* Code For LSchemaUP Goes Here */

        l_schema_up->up_->accept(this);

    }

    void XLERuleParser::visitLSchemaDOWN(LSchemaDOWN *l_schema_down) {
        /* Code For LSchemaDOWN Goes Here */

        l_schema_down->down_->accept(this);

    }

    void XLERuleParser::visitLSchemaUpSymbol(LSchemaUpSymbol *l_schema_up_symbol) {
        /* Code For LSchemaUpSymbol Goes Here */

        l_schema_up_symbol->up_->accept(this);
        l_schema_up_symbol->symbol_->accept(this);

    }

    void XLERuleParser::visitLSchemaDownSymbol(LSchemaDownSymbol *l_schema_down_symbol) {
        /* Code For LSchemaDownSymbol Goes Here */

        l_schema_down_symbol->down_->accept(this);
        l_schema_down_symbol->symbol_->accept(this);

    }

    void XLERuleParser::visitLSchemaDDol(LSchemaDDol *l_schema_d_dol) {
        /* Code For LSchemaDDol Goes Here */

        l_schema_d_dol->down_->accept(this);
        l_schema_d_dol->up_->accept(this);
        l_schema_d_dol->symbol_->accept(this);

    }

    void XLERuleParser::visitLSchemaBRUCB(LSchemaBRUCB *l_schema_brucb) {
        /* Code For LSchemaBRUCB Goes Here */

        l_schema_brucb->up_->accept(this);
        l_schema_brucb->symbol_->accept(this);
        l_schema_brucb->listsorhs_->accept(this);

    }

    void XLERuleParser::visitLSchemaBRDCB(LSchemaBRDCB *l_schema_brdcb) {
        /* Code For LSchemaBRDCB Goes Here */

        l_schema_brdcb->down_->accept(this);
        l_schema_brdcb->symbol_->accept(this);
        l_schema_brdcb->listsorhs_->accept(this);

    }

//cout << "Grammar:" << endl << buffer.str() << endl;
    //GRAMMAR *parse_tree = pGRAMMAR(buffer.str().c_str());
    //if (parse_tree) {
    void XLERuleParser::visitLSchemaDisjunctionSymbols(LSchemaDisjunctionSymbols *l_schema_disjunction_symbols) {
        /* Code For LSchemaDisjunctionSymbols Goes Here */

        l_schema_disjunction_symbols->ssymbol_->accept(this);

    }

    void XLERuleParser::visitSchemaSymbol(SchemaSymbol *schema_symbol) {
        /* Code For SchemaSymbol Goes Here */

        visitIdent(schema_symbol->ident_);

    }

    void XLERuleParser::visitRSchemaSymbol(RSchemaSymbol *r_schema_symbol) {
        /* Code For RSchemaSymbol Goes Here */

        r_schema_symbol->symbol_->accept(this);

    }

    void XLERuleParser::visitRSchemaDown(RSchemaDown *r_schema_down) {
        /* Code For RSchemaDown Goes Here */

        r_schema_down->down_->accept(this);

    }


    void XLERuleParser::visitListORHS(ListORHS *list_orhs) {
        for (ListORHS::iterator i = list_orhs->begin(); i != list_orhs->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListSORHS(ListSORHS *list_sorhs) {
        for (ListSORHS::iterator i = list_sorhs->begin(); i != list_sorhs->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListRHS(ListRHS *list_rhs) {
        for (ListRHS::iterator i = list_rhs->begin(); i != list_rhs->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListSCHEM(ListSCHEM *list_schem) {
        for (ListSCHEM::iterator i = list_schem->begin(); i != list_schem->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListRULE(ListRULE *list_rule) {
        for (ListRULE::iterator i = list_rule->begin(); i != list_rule->end(); ++i) {
            (*i)->accept(this);
        }
    }

    void XLERuleParser::visitListSYMBOL(ListSYMBOL *list_symbol) {
        for (ListSYMBOL::iterator i = list_symbol->begin(); i != list_symbol->end(); ++i) {
            (*i)->accept(this);
        }
    }


    void XLERuleParser::visitInteger(Integer x) {
        /* Code for Integer Goes Here */
    }

    void XLERuleParser::visitChar(Char x) {
        /* Code for Char Goes Here */
    }

    void XLERuleParser::visitDouble(Double x) {
        /* Code for Double Goes Here */
    }

    void XLERuleParser::visitString(String x) {
        /* Code for String Goes Here */
    }

    void XLERuleParser::visitIdent(Ident x) {
        /* Code for Ident Goes Here */
    }

    void XLERuleParser::visitAT(AT *t) {}

    void XLERuleParser::visitRuleS2(RuleS2 *rule_s) {
        /* Code For RuleS2 Goes Here */

        rule_s->lhs_->accept(this);
        rule_s->listrhs_->accept(this);
        rule_s->rulees_->accept(this);

    }

    void XLERuleParser::visitRHSDisjunctionSymbolsAt(RHSDisjunctionSymbolsAt *rhs_disjunction_symbols_at) {
        /* Code For RHSDisjunctionSymbolsAt Goes Here */

        rhs_disjunction_symbols_at->at_->accept(this);
        rhs_disjunction_symbols_at->rhssymbol_->accept(this);

    }


    void XLERuleParser::visitAt(At *at) {
        /* Code For At Goes Here */


    }

}