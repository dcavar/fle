/*! \mainpage The Free Linguistic Environment Project (FLE)

    \author Damir Cavar

    \version 0.1


    \section intro_sec Introduction

    The <a href="">FLE project</a> started as a coding project to develop a new parser platform for grammar engineering
    and experiments using the
    <a href="https://en.wikipedia.org/wiki/Lexical_functional_grammar">Lexical Functional Grammars</a>
    (<a href="https://en.wikipedia.org/wiki/Lexical_functional_grammar">LFG</a>) formalism.
    It can be used with a <a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context-free Grammar</a>
    (<a href="https://en.wikipedia.org/wiki/Context-free_grammar">CFG</a>) formalism,
    a <a href="https://en.wikipedia.org/wiki/Stochastic_context-free_grammar">Probabilisitic-context Free Grammar</a>
    (<a href="https://en.wikipedia.org/wiki/Stochastic_context-free_grammar">PCFG</a>) formalism, and with
    the Xerox Linguistic Environment form of the
    <a href="https://en.wikipedia.org/wiki/Lexical_functional_grammar">LFG</a>-formalism.
    It provides extensions of the LFG-formalism by allowing to use a
    <a href="https://en.wikipedia.org/wiki/Stochastic_context-free_grammar">PCFG</a>-backbone, as well as
    a <a href="https://en.wikipedia.org/wiki/Finite_state_transducer">Weighted Finite State Transducer</a>
    (<a href="https://en.wikipedia.org/wiki/Finite_state_transducer">WFST</a>) model that uses probabilities over
    the bottom up symbol sequences (e.g. the right-hand sides of
    <a href="https://en.wikipedia.org/wiki/Context-free_grammar">CFG</a>-rules).
    The probabilities can in principle be extended to feature representations in form of
    <a href="https://en.wikipedia.org/wiki/Feature_structure">Attribute Value Matrices</a>
    (<a href="https://en.wikipedia.org/wiki/Feature_structure">AVM</a>) that are associated with lexical elements or
    symbols in rules.

    \section contributors_sec Contributors

    Various people have contributed to the discussion of the code:

    - Lwin Moe
    - Tim Gilmanov
    - Kenneth Steimel
    - Joshua Herring
    - Hai Hu


    \section acknowledgements_sec Acknowledgements

    Many people have helped us with different parts of the code or environment.

    - Ron Kaplan
    - Richard Sprout
    - Adam Przepiorkowski



    \section installation_sec Installation

    \subsection requirements_subsec Requirements

    - C++11: GCC/G++ 5.x or clang will be good.
      + make is required in general for all compilations
      + flex is required for the compilation of the LBNF specification of the grammar formalisms
      + bison is required for the compilation of the LBNF specification of the grammar formalisms
    - CMake
      + CMake is part of the CLion distribution, the IDE that we use, but it can be also installed independently
        and it is necessary to generate the Makefile for compilation
    - Boost libraries
      + We use different parts of the Boost libraries. We recommend to install the complete set of the libs.
    - Foma
      + Foma and all Foma-libraries are necessary for the morphological analyzers and compilation of morphologies.
    - BNFC
      + We generate the code for the parsers for all the different grammar formalisms using LBNF as a grammar
        specification and BNFC as a converter.
      + BNFC requires a C++ compiler, flex and bison.


    etc...
*/

#ifndef SKELETON_HEADER
#define SKELETON_HEADER
/* You might want to change the above name. */

#include <iostream>
#include <string>
#include <vector>
#include <tuple>
#include <map>
#include <limits.h>
#include "Absyn.H"
#include "Parser.H"
#include "../FLEWFST.h"



namespace xlerules {

    unsigned const int SYMBOL_TYPE_NONE = 0;
    unsigned const int SYMBOL_TYPE_AST = 1;
    unsigned const int SYMBOL_TYPE_OPT = 2;
    unsigned const int SYMBOL_TYPE_PLAIN = 3;
    unsigned const int SYMBOL_TYPE_DISJUNCTION = 4;

    //using namespace xle;

    using namespace std;

/** A rule type.
 *  It holds the symbol ID of the left-hand-side symbol and the symbol IDs of the right-hand-side symbols in a pair data structure.
 */
    typedef pair<int, vector<int>> rule;


/*! XLERuleParser class */
//! A parser class for XLE-compatible LFG grammars.
/*!
  This the implementation of a *Visitor*-type of parser class that uses the code generated by BNFC to
  parse XLE-grammar files (for the <a href="https://en.wikipedia.org/wiki/Lexical_functional_grammar">LFG</a>-framework).

  It uses FLEWFST as an instance to store the grammar in a
  <a href="https://en.wikipedia.org/wiki/Finite_state_transducer">WFST</a> class serves as the grammar storage.

  Created by <a href="https://linguistlist.org/people/damir_cavar.html">Damir Cavar</a> on 2/23/16.

  See for more details the <a href="http://gorilla.linguistlist.org/fle/">FLE project homepage</a>.
*/
    class XLERuleParser : Visitor {

    public:
        void visitGRAMMAR(GRAMMAR *p);
        void visitRULE(RULE *p);
        void visitLHS(LHS *p);
        void visitRHSSYMBOL(RHSSYMBOL *p);
        void visitRHSSYMB(RHSSYMB *p);
        void visitEPSILONSYMB(EPSILONSYMB *p);
        void visitRHS(RHS *p);
        void visitDRHS(DRHS *p);
        void visitSCHEMA(SCHEMA *p);
        void visitDSYMBOL(DSYMBOL *p);
        void visitSYMBOL(SYMBOL *p);
        void visitVALUE(VALUE *p);
        void visitGrammar(Grammar *p);
        void visitRule(Rule *p);
        void visitLHSSymbol(LHSSymbol *p);
        void visitRHSSymbolAst(RHSSymbolAst *p);
        void visitRHSSymbol(RHSSymbol *p);
        void visitRHSSymbolString(RHSSymbolString *p);
        void visitRHSSymbolEpsilon(RHSSymbolEpsilon *p);
        void visitRHSSymbolEpsUpSymb(RHSSymbolEpsUpSymb *p);
        void visitRHSSymbolEpsUpSymbEnd(RHSSymbolEpsUpSymbEnd *p);
        void visitRHSSymbolOnly(RHSSymbolOnly *p);
        void visitRHSFunctionalSchema(RHSFunctionalSchema *p);
        void visitRHSFunctionalSchemaEnd(RHSFunctionalSchemaEnd *p);
        void visitRHSOptionalSymbol(RHSOptionalSymbol *p);
        void visitRHSOptional(RHSOptional *p);
        void visitRHSDisjunction(RHSDisjunction *p);
        void visitDRHSSymbol(DRHSSymbol *p);
        void visitDRHSFunctionalSchema(DRHSFunctionalSchema *p);
        void visitDRHSOptionalSymbol(DRHSOptionalSymbol *p);
        void visitDRHSOptional(DRHSOptional *p);
        void visitSchemaUpDown(SchemaUpDown *p);
        void visitSchemaFeatUpDown(SchemaFeatUpDown *p);
        void visitSchemaFeatDownVal(SchemaFeatDownVal *p);
        void visitSchemaXcompUpSetDown(SchemaXcompUpSetDown *p);
        void visitSchemaDownSetUp(SchemaDownSetUp *p);
        void visitSchemaDisjSymb(SchemaDisjSymb *p);
        void visitSymbol(Symbol *p);
        void visitValue(Value *p);
        void visitListRULE(ListRULE *p);
        void visitListRHS(ListRHS *p);
        void visitListSCHEMA(ListSCHEMA *p);
        void visitListDRHS(ListDRHS *p);
        void visitListDSYMBOL(ListDSYMBOL *p);

        void visitInteger(Integer x);
        void visitChar(Char x);
        void visitDouble(Double x);
        void visitString(String x);
        void visitIdent(Ident x);

        // special code for our parsing
        //int getIDForSymbol(const string symb);

        //! Return the string symbol for a numerical ID.
        /*!
           \param val The symbol ID as int.
           \return The symbol string.
          Returns the symbol for a symbol ID.
        */
        //const string getSymbolForID(const int val);

        // void getRules(const char *str, FLEWFST &myFST); // GRAMMAR *p);

        void getRules(const char *str);

        // GRAMMAR *XLERuleParser::getParseTree(const char *str);

        XLERuleParser(FLEWFST *wfst);

        ~XLERuleParser();

        //map<string, int> symbolmap; /*!< symbolmap for strings to symbol IDs */

        //map<int, string> revsymbolmap; /*!< the exact reverse of symbolmap, i.e. the symbol ID and the corresponding string */

        //map<int, vector<string>> emissions;

        bool verbose = false;
        /*!< the verbose flag */

        int countRules = 0;
        /*!< number of rules processed */


    private:

        FLEWFST *wfst;

        int startState;
        int targetState;
        int fromState;

        int myLHS; /*!< ID of the left-hand-side symbol */

        vector<pair<int, int>> myRHS; /*!< vector of the right-hand-side symbol IDs and type */

        int lastState = 0; /*!< ID of the last state in myFST */
        // pair<arc_key, arc_val> lastTransition;

        bool optionalSymbol = false;

        bool disjunctionGroup = false;

        int previosSymbolType = SYMBOL_TYPE_NONE;

        vector<int> LHSBuffer;

        bool equalRule = false;

        int lastSymbol;

        double lastWeight;

        int oneButLastInGroup;

        int bracketedGroup = false;

        int groupingStart;

        vector<int> bracketStartState;

        vector<int> bracketEndState;

        vector<int> disjunctionFinalState; // = 0;
        /*!< the state to which a disjunction group transition goes */

        vector<int> disjunctionStartState;
        /*!< the state from which a disjunction group starts */

    };

}

#endif
