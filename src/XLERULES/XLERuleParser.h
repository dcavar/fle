/*! \mainpage The Free Linguistic Environment Project (FLE)

    \author Damir Cavar

    \version 0.1


    \section intro_sec Introduction

    The <a href="">FLE project</a> started as a coding project to develop a new parser platform for grammar engineering
    and experiments using the
    <a href="https://en.wikipedia.org/wiki/Lexical_functional_grammar">Lexical Functional Grammars</a>
    (<a href="https://en.wikipedia.org/wiki/Lexical_functional_grammar">LFG</a>) formalism.
    It can be used with a <a href="https://en.wikipedia.org/wiki/Context-free_grammar">Context-free Grammar</a>
    (<a href="https://en.wikipedia.org/wiki/Context-free_grammar">CFG</a>) formalism,
    a <a href="https://en.wikipedia.org/wiki/Stochastic_context-free_grammar">Probabilisitic-context Free Grammar</a>
    (<a href="https://en.wikipedia.org/wiki/Stochastic_context-free_grammar">PCFG</a>) formalism, and with
    the Xerox Linguistic Environment form of the
    <a href="https://en.wikipedia.org/wiki/Lexical_functional_grammar">LFG</a>-formalism.
    It provides extensions of the LFG-formalism by allowing to use a
    <a href="https://en.wikipedia.org/wiki/Stochastic_context-free_grammar">PCFG</a>-backbone, as well as
    a <a href="https://en.wikipedia.org/wiki/Finite_state_transducer">Weighted Finite State Transducer</a>
    (<a href="https://en.wikipedia.org/wiki/Finite_state_transducer">WFST</a>) model that uses probabilities over
    the bottom up symbol sequences (e.g. the right-hand sides of
    <a href="https://en.wikipedia.org/wiki/Context-free_grammar">CFG</a>-rules).
    The probabilities can in principle be extended to feature representations in form of
    <a href="https://en.wikipedia.org/wiki/Feature_structure">Attribute Value Matrices</a>
    (<a href="https://en.wikipedia.org/wiki/Feature_structure">AVM</a>) that are associated with lexical elements or
    symbols in rules.

    \section contributors_sec Contributors

    Various people have contributed to the discussion of the code:

    - Lwin Moe
    - Tim Gilmanov
    - Kenneth Steimel
    - Joshua Herring
    - Hai Hu


    \section acknowledgements_sec Acknowledgements

    Many people have helped us with different parts of the code or environment.

    - Ron Kaplan
    - Richard Sprout
    - Adam Przepiorkowski



    \section installation_sec Installation

    \subsection requirements_subsec Requirements

    - C++11: GCC/G++ 5.x or clang will be good.
      + make is required in general for all compilations
      + flex is required for the compilation of the LBNF specification of the grammar formalisms
      + bison is required for the compilation of the LBNF specification of the grammar formalisms
    - CMake
      + CMake is part of the CLion distribution, the IDE that we use, but it can be also installed independently
        and it is necessary to generate the Makefile for compilation
    - Boost libraries
      + We use different parts of the Boost libraries. We recommend to install the complete set of the libs.
    - Foma
      + Foma and all Foma-libraries are necessary for the morphological analyzers and compilation of morphologies.
    - BNFC
      + We generate the code for the parsers for all the different grammar formalisms using LBNF as a grammar
        specification and BNFC as a converter.
      + BNFC requires a C++ compiler, flex and bison.


    etc...
*/

#ifndef SKELETON_HEADER
#define SKELETON_HEADER
/* You might want to change the above name. */

#include <iostream>
#include <string>
#include <vector>
#include <tuple>
#include <map>
#include "Absyn.H"
#include "Parser.H"
// #include "../FLEWFST.h"



namespace xlerules {

    unsigned const int SYMBOL_TYPE_NONE = 0;
    unsigned const int SYMBOL_TYPE_AST = 1;
    unsigned const int SYMBOL_TYPE_OPT = 2;
    unsigned const int SYMBOL_TYPE_PLAIN = 3;
    unsigned const int SYMBOL_TYPE_DISJUNCTION = 4;

    //using namespace xle;

    using namespace std;

/** A rule type.
 *  It holds the symbol ID of the left-hand-side symbol and the symbol IDs of the right-hand-side symbols in a pair data structure.
 */
    typedef pair<unsigned long, vector<unsigned long>> rule;


/*! XLERuleParser class */
//! A parser class for XLE-compatible LFG grammars.
/*!
  This the implementation of a *Visitor*-type of parser class that uses the code generated by BNFC to
  parse XLE-grammar files (for the <a href="https://en.wikipedia.org/wiki/Lexical_functional_grammar">LFG</a>-framework).

  It uses FLEWFST as an instance to store the grammar in a
  <a href="https://en.wikipedia.org/wiki/Finite_state_transducer">WFST</a> class serves as the grammar storage.

  Created by <a href="https://linguistlist.org/people/damir_cavar.html">Damir Cavar</a> on 2/23/16.

  See for more details the <a href="http://gorilla.linguistlist.org/fle/">FLE project homepage</a>.
*/
    class XLERuleParser : Visitor {

    public:
        void visitGRAMMAR(GRAMMAR *p);

        void visitRULE(RULE *p);

        void visitRULEES(RULEES *p);

        void visitLHS(LHS *p);

        void visitSYMBOL(SYMBOL *p);

        void visitRHSSYMBOL(RHSSYMBOL *p);

        void visitRHS(RHS *p);

        void visitORHS(ORHS *p);

        void visitSCHEM(SCHEM *p);

        void visitUP(UP *p);

        void visitDOWN(DOWN *p);

        void visitAT(AT *p);

        void visitLEFTSCHEMA(LEFTSCHEMA *p);

        void visitSORHS(SORHS *p);

        void visitSSYMBOL(SSYMBOL *p);

        void visitRIGHTSCHEMA(RIGHTSCHEMA *p);

        void visitGrammar(Grammar *p);

        void visitRuleS(RuleS *p);

        void visitRuleS2(RuleS2 *p);

        void visitRuleEndSymbol(RuleEndSymbol *p);

        void visitLHSSymbolString(LHSSymbolString *p);

        void visitSymbol(Symbol *p);

        void visitSymbolAst(SymbolAst *p);

        void visitRHSSymbolString(RHSSymbolString *p);

        void visitRHSSymbolAstString(RHSSymbolAstString *p);

        void visitRHSSymbol(RHSSymbol *p);

        void visitRHSSymbolOptional(RHSSymbolOptional *p);

        void visitRHSymbolsDisjunction(RHSymbolsDisjunction *p);

        void visitRHSDisjunctionSymbols(RHSDisjunctionSymbols *p);

        void visitRHSDisjunctionSymbolsAt(RHSDisjunctionSymbolsAt *p);

        void visitRHSSymbolFunctionalSchema(RHSSymbolFunctionalSchema *p);

        void visitRHSSymbolFunctionalSchemaMult(RHSSymbolFunctionalSchemaMult *p);

        void visitRHSSymbolFunctionalSchemaOptional(RHSSymbolFunctionalSchemaOptional *p);

        void visitSchema(Schema *p);

        void visitSchemaSimple(SchemaSimple *p);

        void visitUp(Up *p);

        void visitDown(Down *p);

        void visitAt(At *p);

        void visitLSchemaUP(LSchemaUP *p);

        void visitLSchemaDOWN(LSchemaDOWN *p);

        void visitLSchemaUpSymbol(LSchemaUpSymbol *p);

        void visitLSchemaDownSymbol(LSchemaDownSymbol *p);

        void visitLSchemaDDol(LSchemaDDol *p);

        void visitLSchemaBRUCB(LSchemaBRUCB *p);

        void visitLSchemaBRDCB(LSchemaBRDCB *p);

        void visitLSchemaDisjunctionSymbols(LSchemaDisjunctionSymbols *p);

        void visitSchemaSymbol(SchemaSymbol *p);

        void visitRSchemaSymbol(RSchemaSymbol *p);

        void visitRSchemaDown(RSchemaDown *p);

        void visitListORHS(ListORHS *p);

        void visitListSORHS(ListSORHS *p);

        void visitListRHS(ListRHS *p);

        void visitListSCHEM(ListSCHEM *p);

        void visitListRULE(ListRULE *p);

        void visitListSYMBOL(ListSYMBOL *p);

        void visitInteger(Integer x);

        void visitChar(Char x);

        void visitDouble(Double x);

        void visitString(String x);

        void visitIdent(Ident x);

        // special code for our parsing
        //unsigned long getIDForSymbol(const string symb);

        //! Return the string symbol for a numerical ID.
        /*!
           \param val The symbol ID as unsigned long.
           \return The symbol string.
          Returns the symbol for a symbol ID.
        */
        //const string getSymbolForID(const unsigned long val);

        // void getRules(const char *str, FLEWFST &myFST); // GRAMMAR *p);

        void getRules(const char *str);

        // GRAMMAR *XLERuleParser::getParseTree(const char *str);

        //map<string, unsigned long> symbolmap; /*!< symbolmap for strings to symbol IDs */

        //map<unsigned long, string> revsymbolmap; /*!< the exact reverse of symbolmap, i.e. the symbol ID and the corresponding string */

        //map<int, vector<string>> emissions;

        unsigned long count_rules = 0;


        bool verbose = false;

        XLERuleParser();

        ~XLERuleParser();

    private:
        unsigned long myLHS; /*!< ID of the left-hand-side symbol */

        vector<pair<unsigned long, unsigned int>> myRHS; /*!< vector of the right-hand-side symbol IDs and type */

        unsigned long lastState = 0; /*!< ID of the last state in myFST */
        // pair<arc_key, arc_val> lastTransition;

        // FLEWFST *myFST; /*!< the WFST for the grammar */

        bool optionalSymbol = false;
        bool discunjctionSymbol = false;

        unsigned int previosSymbolType = SYMBOL_TYPE_NONE;

    };

}

#endif
