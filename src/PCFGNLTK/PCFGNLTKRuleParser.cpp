/**
 * \class PCFGNLTKRuleParser
 * \file PCFGNLTKRuleParser.cpp
 *
 * \brief Provide a parser for PCFG rules.
 *
 * The code for this parser is indirectly generated from the specification of the BNF
 * grammar for PCFGs and the resulting parser class Skeleton.C generated by BNFC.
 *
 * \author Damir Cavar &lt;damir.cavar@gmail.com&gt;
 *
 * \version 0.1
 *
 * \date 2016/10/25 01:53:00
 *
 * \date Created on: Tue Oct 25 01:55:00 2016
 *
 * \copyright Copyright 2016 by Damir Cavar
 *
 * \license{Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.}
 *
 * \see PCFGNLTKParserTest
 *
 * \note This code should be considered alpha.
 *
 * \bug None
 */


#include "PCFGNLTKRuleParser.h"


namespace pcfgnltk {

    void PCFGNLTKRuleParser::getRules(const char *str) { // }, FLEWFST &newFST) {
        if (verbose)
            cout << "Parsing rule." << endl;
        // myFST = &newFST;
        //myLHS = myFST->FLEEPSILON; /*!< ID of the last state in myFST */
        //lastState = myFST->start_state;
        //lastTransition = make_pair(make_pair((unsigned long)0, (unsigned long)0), make_tuple((unsigned long)0, (unsigned long)0, (double)0.0));

        // change the returned type or the way it is constructed!
        // TODO
        Grammar *parse_tree = pGrammar(str);
        if (parse_tree) {
            parse_tree->accept(this);
        }
    }

    void PCFGNLTKRuleParser::visitGrammar(Grammar *t) {} //abstract class
    void PCFGNLTKRuleParser::visitRule(Rule *t) {} //abstract class
    void PCFGNLTKRuleParser::visitLHS(LHS *t) {} //abstract class
    void PCFGNLTKRuleParser::visitProb(Prob *t) {} //abstract class
    void PCFGNLTKRuleParser::visitRHS(RHS *t) {} //abstract class
    void PCFGNLTKRuleParser::visitSYM(SYM *t) {} //abstract class

    void PCFGNLTKRuleParser::visitGram(Gram *gram)
    {
        /* Code For Gram Goes Here */

        gram->listrule_->accept(this);

    }

    void PCFGNLTKRuleParser::visitRul(Rul *rul)
    {
        /* Code For Rul Goes Here */

        rul->lhs_->accept(this);
        rul->listrhs_->accept(this);

    }

    void PCFGNLTKRuleParser::visitERul(ERul *e_rul)
    {
        /* Code For ERul Goes Here */


    }

    void PCFGNLTKRuleParser::visitLhsS(LhsS *lhs_s)
    {
        /* Code For LhsS Goes Here */

        visitTerminal(lhs_s->terminal_);

    }

    void PCFGNLTKRuleParser::visitProbS(ProbS *prob_s)
    {
        /* Code For ProbS Goes Here */

        visitDouble(prob_s->double_);

    }

    void PCFGNLTKRuleParser::visitRhsSymbol(RhsSymbol *rhs_symbol)
    {
        /* Code For RhsSymbol Goes Here */

        rhs_symbol->listsym_->accept(this);
        rhs_symbol->prob_->accept(this);

    }

    void PCFGNLTKRuleParser::visitRhsTerminal(RhsTerminal *rhs_terminal)
    {
        /* Code For RhsTerminal Goes Here */

        visitTerminal(rhs_terminal->terminal_);
        rhs_terminal->prob_->accept(this);

    }

    void PCFGNLTKRuleParser::visitSymbol(Symbol *symbol)
    {
        /* Code For Symbol Goes Here */

        visitTerminal(symbol->terminal_);

    }


    void PCFGNLTKRuleParser::visitListRule(ListRule *list_rule)
    {
        for (ListRule::iterator i = list_rule->begin() ; i != list_rule->end() ; ++i)
        {
            (*i)->accept(this);
        }
    }

    void PCFGNLTKRuleParser::visitListRHS(ListRHS *list_rhs)
    {
        for (ListRHS::iterator i = list_rhs->begin() ; i != list_rhs->end() ; ++i)
        {
            (*i)->accept(this);
        }
    }

    void PCFGNLTKRuleParser::visitListSYM(ListSYM *list_sym)
    {
        for (ListSYM::iterator i = list_sym->begin() ; i != list_sym->end() ; ++i)
        {
            (*i)->accept(this);
        }
    }


    void PCFGNLTKRuleParser::visitTerminal(Terminal x)
    {
        /* Code for Terminal Goes Here */
    }

    void PCFGNLTKRuleParser::visitInteger(Integer x)
    {
        /* Code for Integer Goes Here */
    }

    void PCFGNLTKRuleParser::visitChar(Char x)
    {
        /* Code for Char Goes Here */
    }

    void PCFGNLTKRuleParser::visitDouble(Double x)
    {
        /* Code for Double Goes Here */
    }

    void PCFGNLTKRuleParser::visitString(String x)
    {
        /* Code for String Goes Here */
    }

    void PCFGNLTKRuleParser::visitIdent(Ident x)
    {
        /* Code for Ident Goes Here */
    }

}