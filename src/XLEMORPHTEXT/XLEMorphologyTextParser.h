/**
 * \class XLEMorphologyTextParser
 * \file XLEMorphologyTextParser.h
 *
 * \brief Provide a parser for XLE MORPHOLOGYTEXT section settings.
 *
 * The code for this parser is indirectly generated from the specification of the BNF
 * grammar for XLE MORPHOLOGYTEXT and the resulting parser class Skeleton.C generated by BNFC.
 *
 * \author Damir Cavar &lt;dcavar@iu.edu&gt;
 *
 * \version 0.1
 *
 * \date 2016/10/25 01:53:00
 *
 * \date Created on: Tue Oct 25 01:55:00 2016
 *
 * \copyright Copyright 2016 by Damir Cavar
 *
 * \license{Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.}
 *
 * \see XLEMorphologyTextParserTest
 *
 * \note This code should be considered alpha.
 *
 * \bug None
 */

#ifndef XLEMORPHTEXT_SKELETON_HEADER
#define XLEMORPHTEXT_SKELETON_HEADER

#include "Absyn.H"
#include "Parser.H"
#include <vector>
#include <iostream>
#include <map>
#include <set>
#include <algorithm>
#include "../SymbolMapper.h"
#include "../PathMapper.h"
#include "../DAG.h"


using namespace std;

namespace xlemorphtext {
    class XLEMorphologyTextParser : public Visitor {
    public:
        void visitMORPHO(MORPHO *p);

        void visitRULE(RULE *p);

        void visitLHS(LHS *p);

        void visitLWORD(LWORD *p);

        void visitRHS(RHS *p);

        void visitRWORD(RWORD *p);

        void visitMorphText(MorphText *p);

        void visitRuleStruct(RuleStruct *p);

        void visitLhsString(LhsString *p);

        void visitLhsInput(LhsInput *p);

        void visitRHSString1(RHSString1 *p);

        void visitBaseA(BaseA *p);

        void visitBaseAP(BaseAP *p);

        void visitBaseAM(BaseAM *p);

        void visitListRULE(ListRULE *p);

        void visitListLWORD(ListLWORD *p);

        void visitListRWORD(ListRWORD *p);

        void visitIdentifier(Identifier x);

        void visitInteger(Integer x);

        void visitChar(Char x);

        void visitDouble(Double x);

        void visitString(String x);

        void visitIdent(Ident x);


        // our launch function
        void getConfig(const char *buffer);
        bool verbose;

        SymbolMapper mySM;
        DAG myDAG;
        string filename = "MorphologyTest";

        map<unsigned int,vector<unsigned int> > MorphoTable; //Final table to store data

    private:

        unsigned int TempMorphID;
        unsigned int TempMorphValID;

        map<string, unsigned int> morph2int;    //Morph to integer converter
        map<unsigned int, string> int2morph;    //Reverse integer to morph converter

        vector<string> property;
        vector<unsigned int> propertyID;

        unsigned int RuleCount;

    };
}

#endif
